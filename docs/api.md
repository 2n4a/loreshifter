# Спецификация API

RESTful API. Все URL относительны относительно
`/api/v0` (предполагаемый URL: `https://ls.elteammate.space/api/v0`).

Авторизация происходит с помощью OAuth2,
токен хранится в cookie `session`. Токен 
помечен как `HttpOnly` и `Secure`.

Если ручка не найдена, возвращается ошибка 404.
Если метод не поддерживается, возвращается ошибка 405.

Все методы, требующие авторизации, проверяют наличие токена в cookie `session`, сверяют его с пользователем в базе данных и возвращают 401, если у пользователя нет доступа к ресурсу. В этом случае возвращается объект типа `ApiError` с кодом `Unauthorized` и сообщением об ошибке.

`Date` представляет из себя строку - время в UTC с точностью как минимум до миллисекунды,
в формате [ISO 8601](https://ru.wikipedia.org/wiki/ISO_8601) и,
при отправке от сервера, в UTC.

# Технические ручки

## GET `/liveness`

Всегда возвращает `200`. Нужно для проверки работоспособности сервиса.

## GET `/login`

Редирект на страницу авторизации от провайдера.

## GET `/login/callback/{provider}`

Авторизация происходит с помощью OAuth2. Когда пользователь заходит на страницу авторизации через `/login`,
его перенаправляет на страницу провайдера авторизации,
например `google`. После авторизации пользователь перенаправляется на страницу `/login/callback/google`.

В этой ручке нужно прочитать токен доступа, сохранить его в cookie `session`, сматчить токен с пользователем в базе данных и сохранить его туда.

Если пользователь не найден, нужно создать нового пользователя в базе данных и возвращать его информацию. Имя 
пользователя нужно запросить у провайдера.

## GET `/logout`

Выйти из текущей сессии.

# Методы для работы с пользователями

## GET `/user/{id}`

Авторизация: опциональна.

Возвращает информацию о пользователе.

### Параметры
- `id` - число, идентификатор пользователя. Если равен `0` или `me` (строка), возвращается информация о себе (требует авторизации).

### Ответ
В случае успеха возвращает объект типа `User` с кодом 200.
Поле `email` возвращается только если пользователь запрашивает
информацию о себе.

Если пользователь не найден, возвращает 404, код ошибки `UserNotFound`.

Если `id` равен `0`, и пользователь не авторизован, возвращает 401, код ошибки `Unauthorized`.

## PUT `/user/{id}`, PUT `/user`

Авторизация: обязательна. Если `id` указан, то
требуется чтобы он совпадал с `id` авторизированного пользователя.

Изменяет информацию о пользователе. Принимает
объект типа `Partial<User>` (подмножество полей).

Поле `id` игнорируется.

Поле `email` изменять пока нельзя. (потом нужно будет реализовать подтверждение электронной почты)

### Ответ
В случае успеха возвращает объект типа `User` с кодом 200.

Если пользователь не найден, возвращает 404, код ошибки `UserNotFound`.

## GET `/user/{id}/history`

TODO

# Методы для работы с мирами

## GET `/world`

Авторизация: необязательна.

Получает список миров с их информацией.

### Параметры
- `limit` - максимальное количество миров в ответе. По умолчанию 25, максимальное 500.
- `offset` - смещение в списке миров.
- `sort` - тип сортировки. У нас пока будет только `lastUpdatedAt`.
- `order` - направление сортировки. `asc` - сначала старые, потом новые, `desc` - наоборот.
- `search` - поисковый запрос, пока не поддерживаем.
- `public` - если 1, фильтровать только опубликованные миры.
- `filter` - фильтры, через запятую. Поддерживается только `owner`. Например, `filter=owner%3D42` возвращает миры владельцем 42 (`%3D` это экранированный символ `=`).

### Ответ
В случае успеха возвращает объект типа `World[]` с кодом 200.
Поле `data` не возвращается. Если миров нет, возврщается пустой массив.

Должны вернуться только опубликованные миры, и если пользователь не авторизован, то еще и не опубликованные,
созданные им.

## GET `/world/{id}`

Авторизация: опциональна.

Получает информацию о мире с идентификатором `id`.

### Параметры
- `id` - идентификатор мира.
- `include` - поля для включения в ответ, перечисленные через запятую. Поддерживается только `data`, поэтому это либо `data`, либо пусто.

### Ответ
В случае успеха возвращает объект типа `World` с кодом 200.

Если мир не найден, возвращает 404, код ошибки `WorldNotFound`.

Если у пользователя нет доступа к ресурсу, возвращает 401, код ошибки `Unauthorized`. У пользователя есть доступ к публичным мирам, и к неопубликованным мирам созданным им.


## POST `/world`

Авторизация: обязательна.

Создает новый мир с информацией из объекта типа `Partial<World>` в теле запроса.

Поля `id`, `owner`, `lastUpdatedAt` и `createdAt` игнорируются.

### Ответ
В случае успеха возвращает объект типа `World` с кодом 200,
созданный мир. 
В нем должны быть проставлены поля `id`, `owner`, `lastUpdatedAt` и `createdAt`.

## PUT `/world/{id}`

Авторизация: обязательна.

Изменяет информацию о мире. Принимает
объект типа `Partial<World>` (подмножество полей).

Поля `id`, `owner`, `lastUpdatedAt` и `createdAt` игнорируются.

### Ответ

В случае успеха возвращает объект типа `World` с кодом 200,
измененный мир.

Если мир не найден, или найден, но он приватный, и пользователь не является владельцем, возвращает 404, код ошибки `WorldNotFound`.

## DELETE `/world/{id}`

Авторизация: обязательна.

Удаляет мир с идентификатором `id`.

### Ответ

В случае успеха возвращает объект типа `World` с кодом 200,
удаленный мир.

Если мир не найден, или найден, но он приватный, и пользователь не является владельцем, возвращает 404, код ошибки `WorldNotFound`.

Если пользователь не является владельцем мира, возвращает 401, код ошибки `Unauthorized`.

## POST `/world/{id}/copy`

Авторизация: обязательна.

Создает копию мира с идентификатором `id`, и возвращает ее.

### Ответ

В случае успеха возвращает объект типа `World` с кодом 200,
созданный мир.

В нем должны быть проставлены поля `id`, `owner`, `lastUpdatedAt` и `createdAt`.

`id` - новый идентификатор мира. `owner` должен быть изменен на пользователя, который создал копию. `lastUpdatedAt` должен быть изменен на текущее время. `createdAt` должен быть изменен на текущее время (?).

Если мир не найден, или найден, но он приватный, и пользователь не является владельцем, возвращает 404, код ошибки `WorldNotFound`.

## GET `/world/{id}/history`

TODO

# Методы для работы с играми

## GET `/game`

Авторизация: необязательна.

Получить список игр с их информацией.

### Параметры
- `limit` - максимальное количество игр в ответе.
- `offset` - смещение в списке игр.
- `sort` - тип сортировки. Пока только `createdAt`.
- `order` - направление сортировки.
- `filter` - фильтры, через запятую. Поддерживаются фильтры
`owner`, `status`, `world` (ищет по id мира), `host` (ищет по id хоста).  
    Например, `filter=owner%3D42,status%3Dplaying` возвращает игры владельцем 42 и состоящие в состоянии `playing` (`%3D` это экранированный символ `=`).

### Ответ

В случае успеха возвращает объект типа `Game[]` с кодом 200.
Даже если ни одна игра не подошла под фильтры, возвращается пустой массив.

В поле `world` возвращается минимальная информация о мире.

Должны вернуться только те игры, к которым пользователь имеет доступ, а именно: публичные; те, в которых игрок участвовал; и те, в которых есть хост.

## GET `/game/{id}`

Получить информацию о игре с идентификатором `id`.
Если `id` равен `0`, возвращается информация о текущей игре.

### Параметры

- `id` - идентификатор игры (число).

### Ответ

В случае успеха возвращает объект типа `Game` с кодом 200.

Если игра не найдена, возвращает 404, код ошибки `GameNotFound`. Если `id` равен `0`, и пользователь не авторизован, возвращает 401, код ошибки `Unauthorized`.
Если `id` равен `0`, но пользователь сейчас не в игре, возвращает 400, код ошибки `PlayerNotInGame`.

Если у пользователя нет доступа к ресурсу, возвращает 401, код ошибки `Unauthorized`. У пользователя есть доступ к публичным играм, к неопубликованным играм созданным им,
а также к играм, в которые он заходил по ссылке.

У каждой игры есть список игроков, которые в ней участвовали.
Как только игрок заходит в игру по ссылке, он добавляется в список игроков. Соответственно, все игроки в этом списке
имеют доступ к игре, даже если игрок вышел из игры.

## GET `/game/code/{code}`

Авторизация: необязательна.

Получить информацию о игре с кодом `code`.

### Параметры

- `code` - код игры (строка). Это отличает игры по коду от игр по id.

### Ответ

В случае успеха возвращает объект типа `Game` с кодом 200.

Если игра не найдена, возвращает 404, код ошибки `GameNotFound`.

В отличие от метода `GET /game`, в этом методе пользоватеюлю достаточно иметь код игры, и не нужно иметь доступ к игре.

## POST `/game`

Авторизация: обязательна.

Создать новую игру с информацией из объекта типа `NewGame` в теле запроса.

Поля понятным образом проставляются в созданную игру.

Поле `code` случайным образом сгенерируется (короткая строка, уникальная среди всех игр).

### Ответ

В случае успеха возвращает объект типа `Game` с кодом 200,
созданную игру.

Если мир не найден, или найден, но он приватный, и пользователь не является владельцем, возвращает 404, код ошибки `WorldNotFound`.

## PUT `/game/{id}`

Авторизация: обязательна.

Изменяет информацию о игре. Принимает объект типа `GameUpdate`.

### Ответ

В случае успеха возвращает объект типа `Game` с кодом 200,
измененную игру.

Если игра не найдена, или найдена, но она приватная, и пользователь не является владельцем, возвращает 404, код ошибки `GameNotFound`.

Если игра уже началась (состояние не `waiting`), возвращает 400, код ошибки `GameAlreadyStarted`.

Если `hostId` указан, но игрока с таким `id` нет в списке игроков, возвращает 400, код ошибки `GameNewHostNotFound`.

Если `maxPlayers` указан, но он больше чем в игроков в игре, возвращает 400, код ошибки `GameMaxPlayersTooBig`.

## POST `/game/{id}/join` или `/game/code/{code}/join`

Авторизация: обязательна.

Присоединиться к игре с идентификатором `id` или кодом `code`.

Если указан `force`, то игрок выходит из текущей игры, если он в ней.

### Параметры

- `id` - идентификатор игры (число).
- `code` - код игры (строка).
- `force` - принудительно присоединиться к игре, даже если игрок сейчас в другой игре. `1` или `0`, по умолчанию `0`.

### Ответ

В случае успеха возвращает объект типа `Game` с кодом 200,
игру, в которой присоединился игрок.

Если игра не найдена, или найдена, но указан `id` (а не `code`) она приватная, и пользователь не в списке игроков, возвращает 404, код ошибки `GameNotFound`.

Если игрок сейчас в другой игре, и параметр `force`
равен `0`, возвращает 400, код ошибки `PlayerAlreadyInGame`.

Если игрок уже в этой игре, и параметр `force`
равен `0`, возвращает 400, код ошибки `PlayerAlreadyInThisGame`.
Иначе возвращает объект типа `Game` с кодом 200 (будто игрок вышел и вошел снова).

## POST `/game/leave`

Авторизация: обязательна.

Выйти из текущей игры.

### Ответ

В случае успеха возвращает пустой объект с кодом 200.

Если игрок сейчас не в игре, возвращает 400, код ошибки `PlayerNotInGame`.


# Асинхронный протокол: комнаты

TODO. Этот протокол нужен, чтобы в меню поддерживать
список комнат в реальном времени.

# Асинхронный протокол: игра

Все методы в этом протоколе работают с текущей игрой, в которую играет пользователь. Соответственно, все методы требуют авторизации. Если пользователь не авторизован, возвращает 401, код ошибки `Unauthorized`. Если пользователь не в игре, возвращает 400, код ошибки `PlayerNotInGame`.

## GET `/play/state`

Возвращает текущее состояние текущей игры. Возвращает объект типа `GameState`.

Не может вернуть `GameStateArchived`, потому что в этом состоянии игрок не может принять участие.

### Ответ

В случае успеха возвращает объект типа `GameState` с кодом 200.

## GET `/play/chat/{chatId}`

Получить сегмент чата текущей игры. Возвращает объект типа `ChatSegment`.

### Параметры

Параметры `before` и `after` не могут быть одновременно указаны.
- `before` - идентификатор сообщения, после которого нужно вернуть сообщения.
    Если не указан, возвращаются последние сообщения.
    Идейно, при заходе в игру, игроку отправляется последний кусок чата.
    Чтобы получить сообщения до него, нужно передать в before id
    сообщения из `previousId`, и API вернет сообщения до этого сообщения
    включительно.
- `after` - идентификатор сообщения, после которого нужно вернуть сообщения.
    Аналогично `before`, но для `nextId`
- `limit` - максимальное количество сообщений в ответе.
    По умолчанию 50, максимальное 500.

### Ответ

В случае успеха возвращает объект типа `ChatSegment` с кодом 200.

Если чата с таким `chatId` нет в игре, возвращает 404, код ошибки `ChatNotFound`.

Если у игрока нет доступа к этому чату (например, это чат создания игрока другого игрока),
возвращает 401, код ошибки `CannotAccessChat`.

## POST `/play/chat/{chatId}/send`

Отправить сообщение в чат текущей игры. В теле запроса содержится объект типа `MessageOut`.

### Параметры

- `chatId` - идентификатор чата.

### Ответ

В случае успеха возвращает отправленный `Message` с кодом 200.

Если чата с таким `chatId` нет в игре, возвращает 404, код ошибки `ChatNotFound`.

Если игрок не может писать в этот чат (например, это чат игры другого игрока),
возвращает 401, код ошибки `CannotAccessChat`.

## POST `/play/kick`

Выгнать игрока из игры.

### Параметры

- `id` - идентификатор игрока (число).

### Ответ

В случае успеха возвращает объект типа `Player` с кодом 200.

Если игрок не в игре, возвращает 404, код ошибки `PlayerNotFound`.

Если игрок не является хостом игры, возвращает 401, код ошибки `NotHost`.

## POST `/play/promote`

Сделать игрока хостом. Игрок, вызвавший этот метод, теряет права хоста.

### Параметры

- `id` - идентификатор игрока (число).

### Ответ

В случае успеха возвращает объект типа `Player` с кодом 200.

Если игрок не в игре, возвращает 404, код ошибки `PlayerNotFound`.

Если игрок не является хостом игры, возвращает 401, код ошибки `NotHost`.


## POST `/play/ready`

Пометить игрока как готовым. Принимает в теле объект типа `Ready`.

### Ответ

В случае успеха возвращает объект типа `Player` с кодом 200.

## POST `/play/start`

Начать игру.

### Параметры

- `id` - идентификатор игры (число).
- `force` - принудительно начать игру, даже если игроки пока не готовы. По умолчанию 0.

### Ответ

В случае успеха возвращает объект типа `Game` с кодом 200.

Если игра не найдена, возвращает 404, код ошибки `GameNotFound`.

Если игрок не является хостом игры, возвращает 401, код ошибки `NotHost`.

Если какой-то игрок не готов, возвращает 400, код ошибки `PlayerNotReady`,
в дополнительном поле `playerIds` перечислены идентификаторы не готовых игроков.

## POST `/play/restart`

Начать новую игру.

После вызова этого метода, нужно создать новую игру в состоянии waiting,
не меняя параметров предыдущей игры, а потом добавить всех игроков в текущей игре в
новую игру, и сделать broadcast нового состояния новой игры.

### Ответ

В случае успеха возвращает объект типа `Game` с кодом 200.

Если игра не в состоянии finished, возвращает 400, код ошибки `GameNotFinished`.

Если игрок не является хостом игры, возвращает 401, код ошибки `NotHost`.

## wss:// `/play/ws`

Подключиться к серверу игры по WebSocket.

Открывает асинхронное соединение с пользователем.

Все сообщения приходят в формате JSON и имеют формат `{type: "ping", id: string, data: any}`.
`id` - уникальный идентификатор сообщения (UUID4). Позволяет скоррелировать ответы на запросы.
Все ответы приходят в таком же формате, `id` ответа и запроса должны совпадать.
Если у сообщения нет непосредственного "запроса" и "ответа", (если в спецификации есть секция "Ответ")
`id` просто можнет быть любым, но все равно UUID4.
Предполагается, что сообщения не могут приводить к ошибкам,
но на всяких случай есть универсальное сообщение `{type: "error", id: string, data: ApiError}`.

### Сообщения

## `{type: "ping", data: Ping}`, server -> client, client -> server

Проверить соединение. Получает объект типа `Ping` с текущей датой и временем
на стороне отправителя.

### Ответ

В случае успеха возвращает объект типа `Pong` с текущей датой и временем
на стороне получателя. Нужно для синхронизации часов.

## `{type: "state", data: Partial<GameState>}`, server -> client

Обновить текущее состояние игры.
Отправляется сразу после подключения, при изменении состояния игры,
изменении состава игроков, выходе из игры и т.д.

## `{type: "chat", data: Partial<ChatSegment>}`, server -> client

Отправить целиком сегмент чата. На практике может быть полезно обновить
состояние чата, например suggestion или interface, при этом не отправляя сообщения.

## `{type: "message", data: Message}`, server -> client

Уведомить о новом сообщении в одном из чатов. Отправляется сервером
после получения любого сообщения игрокам, у которых есть доступ к этому чату.

## `{type: "kicked", data: null}`, server -> client

Уведомить о том, что игрок был выгнан из игры.
